{"code":"/**\r\n * activeEffect保存当前执行的ReactiveEffect，用于处理嵌套effect执行栈,利用js是单线程执行的特点来实现\r\n * 组件就是基于effect来实现嵌套\r\n * effect(() => {       //parent = null\r\n *  state.name = 'lsk'  //activeEffect = e1\r\n *  effect(() => {      //parent = e1\r\n *    state.age = 25    //activeEffect = e2\r\n *  })                  //e2执行完 activeEffect = parent = e1\r\n *  state.sex = 'man'   //activeEffect = e1\r\n * })                   //e1执行完 activeEffect = parent = null\r\n*/\r\nexport let activeEffect = undefined;\r\nexport function effect(fn, options = {}) {\r\n    const _effect = new ReactiveEffect(fn, options.scheduler);\r\n    //默认执行一次\r\n    _effect.run();\r\n    const runner = _effect.run.bind(_effect);\r\n    //将effect实例挂载到run方法上，将run方法返回\r\n    runner.effect = _effect;\r\n    return runner;\r\n}\r\nexport class ReactiveEffect {\r\n    constructor(fn, scheduler) {\r\n        this.parent = null; //effect执行作用域的父effect\r\n        this.fn = null; //用户传入的函数\r\n        this.active = true; //是否是激活状态\r\n        this.deps = []; //收集当前effect依赖了那些属性\r\n        this.fn = fn;\r\n        this.scheduler = scheduler;\r\n    }\r\n    run() {\r\n        //非激活状态下只执行fn\r\n        if (!this.active) {\r\n            return this.fn();\r\n        }\r\n        try {\r\n            this.parent = activeEffect;\r\n            //将当前的effect赋值给activeEffect\r\n            activeEffect = this;\r\n            /**处理分支切换\r\n             * 每次执行之前将清除上次收集依赖的属性\r\n             * 出现场景：\r\n             *  const state = reactive({ flag: true, name: 'zs', age: 20 })\r\n             *  effect(() => {\r\n             *    console.log('render')\r\n             *    app.innerHTML = state.flag ? state.name : state.age\r\n             *  })\r\n             *  setTimeout(() => {\r\n             *    state.flag = false\r\n             *    setTimeout(() => {\r\n             *      console.log('')\r\n             *      state.name = 'ls'\r\n             *    }, 1000)\r\n             * }, 1000)\r\n            */\r\n            cleanupEffect(this);\r\n            //然后用户的执行结果\r\n            return this.fn();\r\n        }\r\n        finally {\r\n            activeEffect = this.parent;\r\n        }\r\n    }\r\n    stop() {\r\n        if (this.active) {\r\n            this.active = false;\r\n            cleanupEffect(this);\r\n        }\r\n    }\r\n}\r\n//判断当前是否需要依赖收集\r\nexport function isTracking() {\r\n    return activeEffect !== undefined;\r\n}\r\n//用来存放target中的属性依赖了那些effect\r\n/**\r\n * targetMap存放结构\r\n * targetMap: {\r\n *  key: { target },\r\n *  value: {\r\n *    map: {   //存放target的属性对应的effect\r\n *      key: 'target[key]',\r\n *      value: set[ReactiveEffect, ReactiveEffect] //去重后的effect\r\n *    }\r\n *  }\r\n * }\r\n*/\r\nconst targetMap = new WeakMap();\r\n//依赖收集\r\nexport function track(target, type, key) {\r\n    //activeEffect = undefined说明当前属性不需要被收集\r\n    if (!isTracking())\r\n        return;\r\n    //获取target在weakMap中的属性映射effect表\r\n    let depsMap = targetMap.get(target);\r\n    if (!depsMap) {\r\n        targetMap.set(target, (depsMap = new Map()));\r\n    }\r\n    //获取当前key值对应的effect\r\n    let dep = depsMap.get(key);\r\n    if (!dep) {\r\n        depsMap.set(key, (dep = new Set()));\r\n    }\r\n    trackEffects(dep);\r\n}\r\n//收集依赖\r\nexport function trackEffects(dep) {\r\n    //判断将当前执行的effect是否已经收集过\r\n    let shouldTrack = !dep.has(activeEffect);\r\n    if (shouldTrack) {\r\n        //将当前target属性所依赖的effect收集起来\r\n        dep.add(activeEffect);\r\n        //将effect所依赖的属性收集起来\r\n        activeEffect.deps.push(dep);\r\n    }\r\n}\r\n//实现依赖触发\r\nexport function trigger(target, type, key) {\r\n    const depsMap = targetMap.get(target);\r\n    //如果为空说明当前对象没有收集依赖\r\n    if (!depsMap)\r\n        return;\r\n    //获取当前属性所有的effect\r\n    let effects = depsMap.get(key);\r\n    triggerEffects(effects);\r\n}\r\n//触发依赖\r\nexport function triggerEffects(effects) {\r\n    if (effects) {\r\n        effects = new Set(effects);\r\n        effects.forEach(effect => {\r\n            /**\r\n             * 如果当前执行的activeEffect不等于要触发的effect就执行run()，不然就会无限递归\r\n             * 出现场景：\r\n             * const state = reactive({ name: 'zs' })\r\n             * effect(() => {\r\n             *  state.name = 'ls'\r\n             *  app.innerHTML = state.name\r\n             * })\r\n             * state.name = 'ls'\r\n            */\r\n            if (effect !== activeEffect) {\r\n                //用户有传调度函数就执行\r\n                if (effect.scheduler) {\r\n                    effect.scheduler();\r\n                }\r\n                else {\r\n                    effect.run();\r\n                }\r\n            }\r\n        });\r\n    }\r\n}\r\n//清除effect中的依赖属性\r\nfunction cleanupEffect(effect) {\r\n    const { deps } = effect;\r\n    for (let i = 0; i < deps.length; i++) {\r\n        deps[i].delete(effect);\r\n    }\r\n    effect.deps.length = 0;\r\n}\r\n//# sourceMappingURL=effect.js.map","references":[],"map":"{\"version\":3,\"file\":\"effect.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../packages/reactivity/src/effect.ts\"],\"names\":[],\"mappings\":\"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\"}"}
